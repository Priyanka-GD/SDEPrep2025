package amazonoa;

import java.util.Arrays;

class GCDVulnerabilitySolver {

    // GCD of two numbers
    public static int findMinVulnerability(int[] arr, int k) {
        int n = arr.length;
        int left = 1;
        int right = n;
        int answer = n;

        while (left <= right) {
            int mid = (left + right) / 2;
            if (isPossible(arr, mid, k)) {
                answer = mid;
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        }
        return answer;
    }

    private static boolean isPossible(int[] arr, int L, int k) {
        if (L == 0) return false;
        int n = arr.length;
        if (L == 1) {
            // All elements must be such that no two consecutive have GCD > 1
            // So, we can change at most k elements to break all such pairs
            int changes = 0;
            for (int i = 0; i < n - 1; i++) {
                if (gcd(arr[i], arr[i + 1]) > 1) {
                    changes++;
                    i++; // skip next element to prevent overlapping issues
                }
            }
            return changes <= k;
        } else {
            // Check if we can ensure no window of L+1 has GCD > 1 with <= k changes
            // The approach is to find all positions where a window of L+1 starts with GCD >1 and break them
            // But this is tricky; alternative approach: for each window of size L+1, if GCD >1, we must change one element
            // But overlapping windows may share elements; changing one can affect multiple windows
            // So, greedy approach: when a window of size L+1 is found with GCD>1, change the last element (rightmost) to break as many future windows as possible
            int changes = 0;
            int[] modifiedArr = Arrays.copyOf(arr, n);
            for (int i = 0; i <= n - (L + 1); ) {
                int currentGcd = modifiedArr[i];
                boolean found = false;
                for (int j = i + 1; j < i + L + 1; j++) {
                    currentGcd = gcd(currentGcd, modifiedArr[j]);
                    if (currentGcd == 1) {
                        break;
                    }
                }
                if (currentGcd > 1) {
                    // Need to change one element in this window
                    changes++;
                    if (changes > k) {
                        return false;
                    }
                    // Ideally, change the rightmost element to a prime not dividing others
                    modifiedArr[i + L] = 1; // 1 ensures GCD with anything is 1
                    i = i + L; // skip ahead to avoid overlapping issues
                } else {
                    i++;
                }
            }
            return changes <= k;
        }
    }

    private static int gcd(int a, int b) {
        while (b != 0) {
            int temp = b;
            b = a % b;
            a = temp;
        }
        return a;
    }

    public static void main(String[] args) {
        int[] arr1 = {2, 2, 4, 9, 6};
        int k1 = 1;
        System.out.println(findMinVulnerability(arr1, k1)); // Output: 2

        int[] arr2 = {5, 10, 20, 10, 15, 5};
        int k2 = 2;
        System.out.println(findMinVulnerability(arr2, k2)); // Output: 2

        int[] arr3 = {4, 2, 4};
        int k3 = 1;
        System.out.println(findMinVulnerability(arr3, k3)); // Output: 1
    }
}
